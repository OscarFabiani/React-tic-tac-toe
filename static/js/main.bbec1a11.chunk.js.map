{"version":3,"sources":["index.js"],"names":["Game","state","history","squares","Array","fill","move","xIsNext","handleClick","i","_this","slice","length","calculateWinner","setState","concat","jumpTo","_this2","this","current","winner","jumpButtonRendersKey","jumpButtonRenders","map","_","react__WEBPACK_IMPORTED_MODULE_5___default","a","createElement","JumpButton","key","className","Board","React","Component","_ref","squareRendersKey","squareRenders","Square","position","value","_ref2","onClick","_ref3","desc","forEach","line","every","v","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.bbec1a11.chunk.js","sourcesContent":["import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.scss';\r\n\r\n\r\n\r\nclass Game extends React.Component {\r\n  state = {\r\n    history: [{\r\n      squares: Array(9).fill(null),\r\n    }],\r\n    move: 0,\r\n    xIsNext: true,\r\n  };\r\n\r\n  handleClick = (i) => {\r\n    const history = this.state.history.slice(0, this.state.move + 1);\r\n    const current = history[history.length - 1];\r\n    const squares = current.squares.slice();\r\n    if (calculateWinner(squares) || squares[i]) {\r\n      return;\r\n    }\r\n\r\n    squares[i] = this.state.xIsNext ? 'X' : 'O';\r\n    this.setState({\r\n      history: history.concat([{\r\n        squares: squares,\r\n      }]),\r\n      move: history.length,\r\n      xIsNext: !this.state.xIsNext,\r\n    });\r\n  }\r\n\r\n  jumpTo = (move) => {\r\n    this.setState({\r\n      //This would update the jump buttons by updating the history to forget the steps following the jumped-to step.\r\n      //history: this.state.history.slice(0, step + 1),\r\n      move: move,\r\n      xIsNext: (move % 2) === 0,\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const history = this.state.history;\r\n    const current = history[this.state.move];\r\n    const winner = calculateWinner(current.squares);\r\n\r\n    let jumpButtonRendersKey = 0;\r\n    const jumpButtonRenders = history.map((_, i) => {\r\n      return (\r\n          <JumpButton\r\n            key={jumpButtonRendersKey++}\r\n            move={i}\r\n            jumpTo={this.jumpTo}/>\r\n      );\r\n    });\r\n\r\n    return (\r\n      <div className=\"game\">\r\n        <h1 className=\"main-title\">React Tic Tac Toe</h1>\r\n        <div className=\"orientation-wrapper\">\r\n          <div className=\"board-and-score\">\r\n            <Board\r\n              squares={current.squares}\r\n              handleClick={this.handleClick}\r\n            />\r\n            <h3 className=\"next-player\">{winner ? 'Winner: ' + winner : 'Next player: ' + (this.state.xIsNext ? 'X' : 'O')}</h3>\r\n          </div>\r\n          <ul className=\"history-list\">\r\n            {jumpButtonRenders}\r\n          </ul>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst Board = ({squares, handleClick}) => {\r\n  let squareRendersKey = 0;\r\n  const squareRenders = Array(9).fill(null).map((_, i) =>\r\n    <Square\r\n      key={squareRendersKey++}\r\n      position={i}\r\n      value={squares[i]}\r\n      handleClick={handleClick}\r\n    />\r\n  );\r\n  return (\r\n      <div className='game-board'>\r\n        {squareRenders}\r\n      </div>\r\n  );\r\n}\r\n\r\n\r\nconst Square = ({position, value, handleClick}) => {\r\n  //This (creating a function in a functional/stateless component)seems to be a bad practice\r\n  //though it also seems to allow me to forgo the use of binding in the Board component's render.\r\n  //The reason this is bad practice is because this component will recreate the handler on every\r\n  //re-render. Maybe I can use useCallback which “returns a memoized version of the callback that\r\n  //only changes if one of the inputs has changed. This is useful when passing callbacks to\r\n  //optimized child components that rely on reference equality to prevent unnecessary renders.”\r\n  //This 'hook' seems to be included in create-react-app of of now(03/30/19), but doesn't seem to\r\n  //be working.\r\n  const onClick = () => {\r\n    handleClick(position);\r\n  }\r\n  return (\r\n    <button className=\"square\" onClick={onClick}>\r\n      {value}\r\n    </button>\r\n  );\r\n}\r\n\r\nconst JumpButton = ({move, jumpTo}) => {\r\n  const desc = move ? 'Go to Move #' + move : 'Go to Game Start';\r\n  const handleClick = () => {\r\n    jumpTo(move);\r\n  }\r\n  return (\r\n    <li className=\"history-item\">\r\n      <button className=\"jump-button\" onClick={handleClick}>{desc}</button>\r\n    </li>\r\n  )\r\n}\r\n\r\n\r\n\r\nReactDOM.render(\r\n  <Game />,\r\n  document.getElementById('root')\r\n);\r\n\r\n//Try to refactor\r\nfunction calculateWinner(squares) {\r\n  const lines = [\r\n    [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6],\r\n  ];\r\n  let winner = null;\r\n  lines.forEach(line => squares[line[0]] && (line.every(v => squares[line[0]] === squares[v])) ? winner = squares[line[0]]: null);\r\n  return winner;\r\n}\r\n\r\n//example calculateWinner logic(currently better than my best)\r\n/*\r\nfor (let i = 0; i < lines.length; i++) {\r\n    const [a, b, c] = lines[i];\r\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\r\n      return squares[a];\r\n    }\r\n  }\r\n  return null;\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n//This is the Square and Board components utilizing an arrow function in the rendering of Square components\r\n//as opposed to binding the handleClick methods and adding a function to the Square component which passes an\r\n//additional prop passed down from the Board component.\r\n//I'm not yet sure which method is best in this situation.\r\n/*\r\nconst Square = ({value, onClick}) => {\r\n  return (\r\n    <button className=\"square\" onClick={onClick}>\r\n      {value}\r\n    </button>\r\n  );\r\n}\r\n\r\nclass Board extends React.Component {\r\n  state = {\r\n    squares: Array(9).fill(null),\r\n    xIsNext: true,\r\n  };\r\n  //NO BINDING HERE\r\n  handleClick(i) {\r\n    const squares = this.state.squares.slice();\r\n    if (calculateWinner(squares) || squares[i]) {\r\n      return;\r\n    }\r\n    squares[i] = this.state.xIsNext ? 'X' : 'O';\r\n    this.setState({\r\n      squares: squares,\r\n      xIsNext: !this.state.xIsNext,\r\n    })\r\n  }\r\n\r\n  render() {\r\n    const winner = calculateWinner(this.state.squares);\r\n    const squareRenders = this.state.squares.map((_, i) =>\r\n      <Square\r\n        key={i}\r\n        place={i}\r\n        value={this.state.squares[i]}\r\n        //ARROW FUNCTION USED TO PASS 'i'\r\n        onClick={() => this.handleClick(i)}\r\n      />\r\n    );\r\n    return (\r\n      <div>\r\n        <h3>{winner ? 'Winner: ' + winner : 'Next player: ' + (this.state.xIsNext ? 'X' : 'O')}</h3>\r\n        <div className='game-board'>\r\n          {squareRenders}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n*/\r\n\r\n//This logic was placed within the render method of the Board component and was removed in\r\n//favor of being implemented as a method of the Board comonent.\r\n/*\r\nconst squareRenders = this.state.squares.map((_, i) =>\r\n      <Square\r\n        key={i}\r\n        position={i}\r\n        value={this.state.squares[i]}\r\n        onClick={this.handleClick}\r\n      />\r\n    );\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n//CONTINUE TO REFACTOR AND COMPARE"],"sourceRoot":""}